---
title: 拷贝构造函数给函数参数传值
date: 2020-06-09 11:18:37
tags:
    - C++
    - 编程
---

我对 C++中 拷贝构造函数 以值传递的方式 给函数参数传值 的理解

还有，为什么是值传递呢？

要看懂本文章你需要了解：

1. C++基础语法
2. C++中的引用
3. C++中的class（类和对象）
4. 构造函数和析构函数
5. 构造函数的分类及调用

注意：请按照编号顺序查看代码说明，请从下往上看

<!-- more -->

```c++

class Person
{

public:

    
	Person()
	{
		cout << "默认构造函数调用" << endl;
	}
	
	Person(int age)
	{
		m_Age = age;
		
		cout << "有参构造函数调用" << endl;
	}


—————————————————————————————————————————————————————————————————————————————————————————————
	
	
	// 8.因为doWork传入的参数是p2，所以会自动调用拷贝构造函数

	// p2将会以引用的方式传入拷贝构造函数。

	// 所以，当编译器发现是引用，会自动转化 const Person& p 为 const int* const p = &p1

	// 注意，这里的p1是只读的，因为被const修饰了，不可修改，p1的作用域也只限于拷贝构造函数内。

	Person(const Person& p)
	{

		// 9.注意，拷贝构造函数是以引用作为它的参数，其实在这个函数内还是可以修改实参的

		//p.m_Age = 12; 因为拷贝构造函数使用了引用，所以去掉const就可以更改实参了


		// 10.我们知道构造函数的一个目的是进行初始化操作

		// 我们将m_Age初始化，在这里，我们就算实现了所谓的值传递

		m_Age = p.m_Age;

		cout << "拷贝构造函数调用" << endl;
	}


	~Person001()
	{
		cout << "析构函数调用" << endl;
	}
	
	int m_Age;
};


// 7.这里相当于写了 Person p = p1;

// 使用了隐式转换法来调用 （调用的方法有3种，括号法、显示法、隐式转换法，请自行去了解）

// 创建对象的时候，构造函数会自动调用，而且只调用一次。

// 因为传入的参数是p1所以，会自动调用拷贝构造构造函数

void doWork(Person p) //这里会自动调用拷贝构造函数
{
    // 11.好，回到这里

    // p.m_Age原本等于10，我们现在尝试修改p.m_Age为12，看看能不能改变实参

	p.m_Age = 12;
}


void test()
{
    // 3.实例化对象p1，运行这行代码时会调用“默认构造函数”，然后在text()函数销毁前执行“析构函数”

	Person p1;
    

    // 4.给p1中的m_Age赋值为10

	p1.m_Age = 10;


    // 5.屏幕显示：Person age = 10

	cout << "Person age = " << p1.m_Age << endl; 
    

    // 6.p1做为参数传入doWork函数，注意这里是值传递（那为什么呢？）

	doWork(p1);


    // 12.并不能改变实参，所以我们可以知道，拷贝构造函数 以值传递的方式 给函数参数 传值

	cout << "Person age = " << p1.m_Age << endl;
}


// 1.首先看这里，这里是主函数，程序的开始

int main()
{
    // 2.调用test函数

	test();

	system("pause");

	return 0;
}

```

如果文章有错误，欢迎指正：2892870137@qq.com