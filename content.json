{"meta":{"title":"James Liu's Blog","subtitle":"Recording Time, Experience and Knowledge","description":"","author":"James Liu","url":"http://JamesLiu.com","root":"/"},"pages":[{"title":"Categories","date":"2020-04-12T23:58:01.000Z","updated":"2020-04-13T02:18:19.342Z","comments":true,"path":"categories/index.html","permalink":"http://jamesliu.com/categories/index.html","excerpt":"","text":""},{"title":"About Me 关于我","date":"2020-04-13T01:32:40.000Z","updated":"2020-04-13T02:28:22.899Z","comments":true,"path":"about/index.html","permalink":"http://jamesliu.com/about/index.html","excerpt":"","text":"有待更新……"},{"title":"MyTags","date":"2020-04-12T05:27:11.000Z","updated":"2020-04-12T05:31:22.911Z","comments":true,"path":"tags/index.html","permalink":"http://jamesliu.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"虚函数实现原理","slug":"虚函数实现原理","date":"2020-06-20T07:15:35.000Z","updated":"2020-06-20T07:56:44.469Z","comments":true,"path":"2020/06/20/虚函数实现原理/","link":"","permalink":"http://jamesliu.com/2020/06/20/%E8%99%9A%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","excerpt":"今天学C++多态时，对虚函数实现原理有些疑惑。 然后爬了很多文，看了很多教程。 经过一系列研究，以下是我的理解：","text":"今天学C++多态时，对虚函数实现原理有些疑惑。 然后爬了很多文，看了很多教程。 经过一系列研究，以下是我的理解： 注意：请按照编号顺序查看代码说明 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;//动物类class Animal &#123;public: virtual void speak() &#123; // 1. //没写virtual时 这是一个非静态的成员函数 //它不属于类上面，是分开存储的 //现在这个类是空类，空类的大小是1字节 //但如果加了virtual后，类大小为4字节,变成虚函数 //这个类的结构发生了变化，因为里面会添加一个4字节大小的指针 //叫vfptr（virtual function pointer 虚函数（表）指针） //这个指针会指向一个虚函数表 //vftable（virtual function table 虚函数表） //所有的虚函数都是通过 虚函数指针 在虚函数表中调用的 //虚函数表会记录这个类中所有的虚函数的地址， //可以理解为 它是一个 只存放这个类的虚函数的地址表 //不管你在这个类中写多少个虚函数，都不会影响这个实例的大小 //依旧是4字节，因为虚函数也是分开存储的 //小知识：在C++的标准说明书中说到 //编译器必须要保证 虚函数表的指针 存在于对象的实例中 最前面的位置 //也就是那个对象最开始的地址 //（这是为了保证正确取到虚函数的偏移量） cout &lt;&lt; \"动物在说话\" &lt;&lt; endl; &#125;&#125;;//猫类class Cat : public Animal&#123;public: // 2. // 重写函数：函数返回值类型，函数名，形参列表 要完全相同 才叫重写 // 这里写不写 virtual都可以 // 如果父类的是虚函数的话 重写时 不写的virtual话 也会默认是virtual void speak() &#123;cout &lt;&lt; \"小猫在说话\" &lt;&lt; endl&#125;&#125;;//狗类class Dog : public Animal&#123;public: void speak() &#123;cout &lt;&lt; \"小狗在说话\" &lt;&lt; endl;&#125;&#125;;// 5.// 动态多态满足条件：// 1.有继承关系// 2.子类要重写父类的虚函数//（重写：函数返回值类型，函数名，形参列表 要完全相同 才叫重写）// 动态多态使用：// 父类的指针或者引用 执行子类对象// 4.void doSpeak(Animal&amp; animal) // Animal &amp; animal = cat; //C++中允许父子之间的类型转换，不需要做强制类型转换&#123; //引用的本质是起别名，引用里有一个常量指针指向cat //引用本质：Animal* const animal = &amp;cat; //所以当用animal这个引用调用speak函数时，实际上是： //引用通过Cat的首地址找到虚函数表，从虚函数表通过指针偏移量获取speak函数的地址，从而调用speak函数 //因为speak的作用域再Cat下面，所以会调用Cat下的speak animal.speak();&#125;void test01()&#123; Cat cat; // 3. //已知创建子类时会创建一个父类 //父类中虚函数表内部记录了虚函数的地址：&amp;Animal::speak //然后继承给子类 //子类就拥有了所有父类属性，此时子类中虚函数表的地址依然还是 &amp;Animal::speak //但是！！ //我们重写了子类函数（此时重写的函数默认是vitural，所以vitural写不写都可以） //这时虚函数指针 指向的虚函数表 因为重写 就覆盖&amp;Animal::speak 变成 &amp;Cat::speak 这个地址 doSpeak(cat); Dog dog; doSpeak(dog);&#125;void test02() &#123;cout &lt;&lt; \"sizeof Animal = \" &lt;&lt; sizeof(Animal) &lt;&lt; endl;&#125;int main()&#123; test01(); test02(); system(\"pause\"); return 0;&#125; 如果文章有误，欢迎指正: 2892870137@qq.com","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://jamesliu.com/tags/C/"},{"name":"编程","slug":"编程","permalink":"http://jamesliu.com/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"拷贝构造函数给函数参数传值","slug":"拷贝构造函数给函数参数传值","date":"2020-06-09T03:18:37.000Z","updated":"2020-06-10T00:59:54.482Z","comments":true,"path":"2020/06/09/拷贝构造函数给函数参数传值/","link":"","permalink":"http://jamesliu.com/2020/06/09/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%99%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E5%80%BC/","excerpt":"我对 C++中 拷贝构造函数 以值传递的方式 给函数参数传值 的理解 还有，为什么是值传递呢？ 要看懂本文章你需要了解： C++基础语法 C++中的引用 C++中的class（类和对象） 构造函数和析构函数 构造函数的分类及调用 注意：请按照编号顺序查看代码说明，请从下往上看","text":"我对 C++中 拷贝构造函数 以值传递的方式 给函数参数传值 的理解 还有，为什么是值传递呢？ 要看懂本文章你需要了解： C++基础语法 C++中的引用 C++中的class（类和对象） 构造函数和析构函数 构造函数的分类及调用 注意：请按照编号顺序查看代码说明，请从下往上看 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116class Person&#123;public: Person() &#123; cout &lt;&lt; \"默认构造函数调用\" &lt;&lt; endl; &#125; Person(int age) &#123; m_Age = age; cout &lt;&lt; \"有参构造函数调用\" &lt;&lt; endl; &#125;————————————————————————————————————————————————————————————————————————————————————————————— // 8.因为doWork传入的参数是p1，所以会自动调用拷贝构造函数 // p1将会以引用的方式传入拷贝构造函数。 // 所以，当编译器发现是引用，会自动转化 const Person&amp; p 为 const int* const p = &amp;p1 // 注意，这里的p1是只读的，因为被const修饰了，不可修改，p1的作用域也只限于拷贝构造函数内。 Person(const Person&amp; p) &#123; // 9.注意，拷贝构造函数是以引用作为它的参数，其实在这个函数内还是可以修改实参的 //p.m_Age = 12; 因为拷贝构造函数使用了引用，所以去掉const就可以更改实参了 // 10.我们知道构造函数的一个目的是进行初始化操作 // 我们将m_Age初始化，在这里，我们就算实现了所谓的值传递 m_Age = p.m_Age; cout &lt;&lt; \"拷贝构造函数调用\" &lt;&lt; endl; &#125; ~Person001() &#123; cout &lt;&lt; \"析构函数调用\" &lt;&lt; endl; &#125; int m_Age;&#125;;// 7.这里相当于写了 Person p = p1;// 使用了隐式转换法来调用 （调用的方法有3种，括号法、显示法、隐式转换法，请自行去了解）// 创建对象的时候，构造函数会自动调用，而且只调用一次。// 因为传入的参数是p1所以，会自动调用拷贝构造构造函数void doWork(Person p) //这里会自动调用拷贝构造函数&#123; // 11.好，回到这里 // p.m_Age原本等于10，我们现在尝试修改p.m_Age为12，看看能不能改变实参 p.m_Age = 12;&#125;void test()&#123; // 3.实例化对象p1，运行这行代码时会调用“默认构造函数”，然后在text()函数销毁前执行“析构函数” Person p1; // 4.给p1中的m_Age赋值为10 p1.m_Age = 10; // 5.屏幕显示：Person age = 10 cout &lt;&lt; \"Person age = \" &lt;&lt; p1.m_Age &lt;&lt; endl; // 6.p1做为参数传入doWork函数，注意这里是值传递（那为什么呢？） doWork(p1); // 12.并不能改变实参，所以我们可以知道，拷贝构造函数 以值传递的方式 给函数参数 传值 cout &lt;&lt; \"Person age = \" &lt;&lt; p1.m_Age &lt;&lt; endl;&#125;// 1.首先看这里，这里是主函数，程序的开始int main()&#123; // 2.调用test函数 test(); system(\"pause\"); return 0;&#125; 如果文章有错误，欢迎指正：2892870137@qq.com","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://jamesliu.com/tags/C/"},{"name":"编程","slug":"编程","permalink":"http://jamesliu.com/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"Markdown简单入门","slug":"Markdown","date":"2020-04-13T03:29:52.000Z","updated":"2020-06-09T03:20:53.408Z","comments":true,"path":"2020/04/13/Markdown/","link":"","permalink":"http://jamesliu.com/2020/04/13/Markdown/","excerpt":"以下是Markdown的最基本使用方法，忘记便回来看看，也就入了门","text":"以下是Markdown的最基本使用方法，忘记便回来看看，也就入了门 一级标题# 一级标题 二级标题## 二级标题 三级标题### 三级标题 分割线：--- 列表1 列表2 子列表1 子列表2 孙列表1 孙列表2 123456- 列表1- 列表2 - 子列表1 - 子列表2 - 孙列表1 - 孙列表2 分割线 ：--- 超链接 ：[超链接](https://github.com/H-James) 图片 ： 1![图片](https:&#x2F;&#x2F;h-james.github.io&#x2F;2020&#x2F;04&#x2F;13&#x2F;Markdown&#x2F;003_Markdown简单入门-rickAndmorty.png) 分割线 ：--- 斜字体 ：*斜字体* 粗字体 ：**粗字体** 一行代码 ： &lt;html&gt;代码&lt;/html&gt; 一段代码 ： 123456&lt;html&gt; &lt;head&gt; &lt;title&gt;代码&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 引用内容&gt; 引用内容","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://jamesliu.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"markdown","slug":"markdown","permalink":"http://jamesliu.com/tags/markdown/"}]}],"categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://jamesliu.com/tags/C/"},{"name":"编程","slug":"编程","permalink":"http://jamesliu.com/tags/%E7%BC%96%E7%A8%8B/"},{"name":"前端","slug":"前端","permalink":"http://jamesliu.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"markdown","slug":"markdown","permalink":"http://jamesliu.com/tags/markdown/"}]}