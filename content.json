{"meta":{"title":"James Liu's Blog","subtitle":"Recording Time, Experience and Knowledge","description":"","author":"James Liu","url":"http://JamesLiu.com","root":"/"},"pages":[{"title":"About Me 关于我","date":"2020-04-13T01:32:40.000Z","updated":"2020-04-13T02:28:22.899Z","comments":true,"path":"about/index.html","permalink":"http://jamesliu.com/about/index.html","excerpt":"","text":"有待更新……"},{"title":"MyTags","date":"2020-04-12T05:27:11.000Z","updated":"2020-04-12T05:31:22.911Z","comments":true,"path":"tags/index.html","permalink":"http://jamesliu.com/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2020-04-12T23:58:01.000Z","updated":"2020-04-13T02:18:19.342Z","comments":true,"path":"categories/index.html","permalink":"http://jamesliu.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"虚析构和纯虚析构原理","slug":"虚析构和纯虚析构原理","date":"2020-06-23T02:41:51.000Z","updated":"2020-06-23T08:11:54.137Z","comments":true,"path":"2020/06/23/虚析构和纯虚析构原理/","link":"","permalink":"http://jamesliu.com/2020/06/23/%E8%99%9A%E6%9E%90%E6%9E%84%E5%92%8C%E7%BA%AF%E8%99%9A%E6%9E%90%E6%9E%84%E5%8E%9F%E7%90%86/","excerpt":"直接上代码：请根据编号查看代码说明。 先总结: 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构 拥有纯虚析构函数的类也属于抽象类","text":"直接上代码：请根据编号查看代码说明。 先总结: 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构 拥有纯虚析构函数的类也属于抽象类 animal类 1234567891011121314151617181920212223242526//3.class animal&#123;public: animal() &#123; cout &lt;&lt; \"animal构造函数调用\" &lt;&lt; endl; &#125; //能调用子类析构函数 来释放堆区的 决方法： //利用虚析构可以解决父类指针释放子类对象时不干净的问题 //virtual ~animal() &#123; cout &lt;&lt; \"animal虚析构函数调用\" &lt;&lt; endl; &#125; //而如果想避免基类实例化，则可以将析构函数写成纯虚析构 //但因为派生类（子类）不可能来实现基类（父类）的析构函数， //所以基类析构函数虽然可以标为纯虚，但是仍必须实现析构函数， //否则派生类无法继承，也无法编译通过。 //纯虚析构 要声明也要实现（类外定义） //有了纯虚析构之后，这个类也属于抽象类，并无法实例化对象 virtual ~animal() = 0; virtual void speak() = 0; &#125;;//纯虚析构函数要类外定义animal::~animal() &#123; cout &lt;&lt; \"animal纯虚析构函数调用\" &lt;&lt; endl; &#125; cat类，里面继承了父类animal 123456789101112131415161718192021222324// 4.class cat : public animal&#123;public: cat(string name) &#123; cout &lt;&lt; \"cat构造函数调用\" &lt;&lt; endl; m_Name = new string(name); &#125; virtual void speak() &#123; cout &lt;&lt; *m_Name &lt;&lt; \"小猫在说话\" &lt;&lt; endl; &#125; ~cat() &#123; if (m_Name != NULL) &#123; cout &lt;&lt; \"cat析构函数调用\" &lt;&lt; endl; delete m_Name; m_Name = NULL; &#125; &#125; string* m_Name;&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// 5.void te01()&#123; //父类指针指向了一个开辟了一个在堆区的子类数据 animal* a = new cat(\"Tom\"); //new一个在堆区的cat类型的对象，cat继承自animal //我们知道创建子类时会先创建父类 //所以先调用了animal的构造函数 //再是cat的构造函数 //亿点细节： //在创建父类时，如果发现父类中有虚函数 //编译器就会使用一个叫虚函数表的东西，保存所有的虚函数，包括纯虚函数 //在这里,animal父类的虚函数表中，有两个虚函数 /* class animal size(4): +--- 0 | (vfptr) +--- animal::$vftable@: | &amp;animal_mata | 0 0 | &amp;animal::(dtor) 1 | &amp;animal::speak */ //&amp;animal::(dtor) 就是animal的纯虚构函数的地址 //dtor是destructor的缩写，是析构函数的意思，中文直译叫\"垃圾焚毁炉\" //&amp;animal::speak 就是speak虚函数的地址 //接着，子类继承了这个表，重写了speak。 /* class cat size(8): +--- 0 | +--- (base class animal) 0 | | &#123;vfptr&#125; | +--- 4 | m_Name +--- cat::$vftable@: | &amp;cat_meta | 0 | &amp;cat::(dtor) 0 | &amp;cat::speak */ //这个dtor我不知道算不算重写，我觉的应该是的 //但我不了解原理，所以搬了一个别人的解释： //当父类析构函数定义为虚函数后，子类默认就是虚析构函数，跟普通成员函数一样 //现在将父类析构函数 定义为虚函数，子类再继承了 父类的虚函数表 //子类的虚函数表中，就存在父类的 虚析构函数的地址， //但子类的析构函数 也是虚函数，所以重写了自己虚函数表中 父类虚析构函数的地址 //变成了子类的虚析构函数地址 //虽然父子的析构函数名字不一样，但是他们占同一个坑 //（即父子析构函数在虚函数表中的位置是一样的，否则就不存在多态了） //用父类指针指向子类，并最后通过父类指针删除子类对象的时候， //发现animal类的析构函数是虚函数，就到子类对象的虚函数表里找析构函数 //此时就会调用虚函表中 子类的虚析构函数 很好的防止了内存泄漏 //然后还有个问题， //既然子类的虚函数表中只有子类虚析构函数，那它怎样析构父类呢？ //父类的析构函数又在哪呢？ //其实在子类的析构函数中，底层包含着对父类析构函数的调用 //原因我认为是： //对象都存放在栈中，创建子类对象先调用父类的对象， //父类对象压入栈，然后是子类对象入栈，由于栈是先进后出， //delete父类的时候就先调用子类对象，在调用父类对象 a-&gt;speak(); //因为子类的speak重写了父类的speak，父类指针调用的是子类的speak delete a; //父类指针在析构的时候 不会调用子类中的析构函数 //导致子类如果有堆区属性，出现内存泄漏 //原因是指针a是animal类型的指针，也就是父类类型的指针 //释放a时只进行animal类的析构函数。 //父类析构函数变成虚析构之后，这个问题就解决了 &#125; 1234567// 1.int main()&#123; // 2. te01(); return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://jamesliu.com/tags/C/"},{"name":"编程","slug":"编程","permalink":"http://jamesliu.com/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"虚函数实现原理","slug":"虚函数实现原理","date":"2020-06-20T07:15:35.000Z","updated":"2020-06-20T07:56:44.469Z","comments":true,"path":"2020/06/20/虚函数实现原理/","link":"","permalink":"http://jamesliu.com/2020/06/20/%E8%99%9A%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","excerpt":"今天学C++多态时，对虚函数实现原理有些疑惑。 然后爬了很多文，看了很多教程。 经过一系列研究，以下是我的理解：","text":"今天学C++多态时，对虚函数实现原理有些疑惑。 然后爬了很多文，看了很多教程。 经过一系列研究，以下是我的理解： 注意：请按照编号顺序查看代码说明 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;//动物类class Animal &#123;public: virtual void speak() &#123; // 1. //没写virtual时 这是一个非静态的成员函数 //它不属于类上面，是分开存储的 //现在这个类是空类，空类的大小是1字节 //但如果加了virtual后，类大小为4字节,变成虚函数 //这个类的结构发生了变化，因为里面会添加一个4字节大小的指针 //叫vfptr（virtual function pointer 虚函数（表）指针） //这个指针会指向一个虚函数表 //vftable（virtual function table 虚函数表） //所有的虚函数都是通过 虚函数指针 在虚函数表中调用的 //虚函数表会记录这个类中所有的虚函数的地址， //可以理解为 它是一个 只存放这个类的虚函数的地址表 //不管你在这个类中写多少个虚函数，都不会影响这个实例的大小 //依旧是4字节，因为虚函数也是分开存储的 //小知识：在C++的标准说明书中说到 //编译器必须要保证 虚函数表的指针 存在于对象的实例中 最前面的位置 //也就是那个对象最开始的地址 //（这是为了保证正确取到虚函数的偏移量） cout &lt;&lt; \"动物在说话\" &lt;&lt; endl; &#125;&#125;;//猫类class Cat : public Animal&#123;public: // 2. // 重写函数：函数返回值类型，函数名，形参列表 要完全相同 才叫重写 // 这里写不写 virtual都可以 // 如果父类的是虚函数的话 重写时 不写的virtual话 也会默认是virtual void speak() &#123;cout &lt;&lt; \"小猫在说话\" &lt;&lt; endl&#125;&#125;;//狗类class Dog : public Animal&#123;public: void speak() &#123;cout &lt;&lt; \"小狗在说话\" &lt;&lt; endl;&#125;&#125;;// 5.// 动态多态满足条件：// 1.有继承关系// 2.子类要重写父类的虚函数//（重写：函数返回值类型，函数名，形参列表 要完全相同 才叫重写）// 动态多态使用：// 父类的指针或者引用 执行子类对象// 4.void doSpeak(Animal&amp; animal) // Animal &amp; animal = cat; //C++中允许父子之间的类型转换，不需要做强制类型转换&#123; //引用的本质是起别名，引用里有一个常量指针指向cat //引用本质：Animal* const animal = &amp;cat; //所以当用animal这个引用调用speak函数时，实际上是： //引用通过Cat的首地址找到虚函数表，从虚函数表通过指针偏移量获取speak函数的地址，从而调用speak函数 //因为speak的作用域再Cat下面，所以会调用Cat下的speak animal.speak();&#125;void test01()&#123; Cat cat; // 3. //已知创建子类时会创建一个父类 //父类中虚函数表内部记录了虚函数的地址：&amp;Animal::speak //然后继承给子类 //子类就拥有了所有父类属性，此时子类中虚函数表的地址依然还是 &amp;Animal::speak //但是！！ //我们重写了子类函数（此时重写的函数默认是vitural，所以vitural写不写都可以） //这时虚函数指针 指向的虚函数表 因为重写 就覆盖&amp;Animal::speak 变成 &amp;Cat::speak 这个地址 doSpeak(cat); Dog dog; doSpeak(dog);&#125;void test02() &#123;cout &lt;&lt; \"sizeof Animal = \" &lt;&lt; sizeof(Animal) &lt;&lt; endl;&#125;int main()&#123; test01(); test02(); system(\"pause\"); return 0;&#125; 如果文章有误，欢迎指正: 2892870137@qq.com","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://jamesliu.com/tags/C/"},{"name":"编程","slug":"编程","permalink":"http://jamesliu.com/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"拷贝构造函数给函数参数传值","slug":"拷贝构造函数给函数参数传值","date":"2020-06-09T03:18:37.000Z","updated":"2020-06-10T00:59:54.482Z","comments":true,"path":"2020/06/09/拷贝构造函数给函数参数传值/","link":"","permalink":"http://jamesliu.com/2020/06/09/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%99%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E5%80%BC/","excerpt":"我对 C++中 拷贝构造函数 以值传递的方式 给函数参数传值 的理解 还有，为什么是值传递呢？ 要看懂本文章你需要了解： C++基础语法 C++中的引用 C++中的class（类和对象） 构造函数和析构函数 构造函数的分类及调用 注意：请按照编号顺序查看代码说明，请从下往上看","text":"我对 C++中 拷贝构造函数 以值传递的方式 给函数参数传值 的理解 还有，为什么是值传递呢？ 要看懂本文章你需要了解： C++基础语法 C++中的引用 C++中的class（类和对象） 构造函数和析构函数 构造函数的分类及调用 注意：请按照编号顺序查看代码说明，请从下往上看 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116class Person&#123;public: Person() &#123; cout &lt;&lt; \"默认构造函数调用\" &lt;&lt; endl; &#125; Person(int age) &#123; m_Age = age; cout &lt;&lt; \"有参构造函数调用\" &lt;&lt; endl; &#125;————————————————————————————————————————————————————————————————————————————————————————————— // 8.因为doWork传入的参数是p1，所以会自动调用拷贝构造函数 // p1将会以引用的方式传入拷贝构造函数。 // 所以，当编译器发现是引用，会自动转化 const Person&amp; p 为 const int* const p = &amp;p1 // 注意，这里的p1是只读的，因为被const修饰了，不可修改，p1的作用域也只限于拷贝构造函数内。 Person(const Person&amp; p) &#123; // 9.注意，拷贝构造函数是以引用作为它的参数，其实在这个函数内还是可以修改实参的 //p.m_Age = 12; 因为拷贝构造函数使用了引用，所以去掉const就可以更改实参了 // 10.我们知道构造函数的一个目的是进行初始化操作 // 我们将m_Age初始化，在这里，我们就算实现了所谓的值传递 m_Age = p.m_Age; cout &lt;&lt; \"拷贝构造函数调用\" &lt;&lt; endl; &#125; ~Person001() &#123; cout &lt;&lt; \"析构函数调用\" &lt;&lt; endl; &#125; int m_Age;&#125;;// 7.这里相当于写了 Person p = p1;// 使用了隐式转换法来调用 （调用的方法有3种，括号法、显示法、隐式转换法，请自行去了解）// 创建对象的时候，构造函数会自动调用，而且只调用一次。// 因为传入的参数是p1所以，会自动调用拷贝构造构造函数void doWork(Person p) //这里会自动调用拷贝构造函数&#123; // 11.好，回到这里 // p.m_Age原本等于10，我们现在尝试修改p.m_Age为12，看看能不能改变实参 p.m_Age = 12;&#125;void test()&#123; // 3.实例化对象p1，运行这行代码时会调用“默认构造函数”，然后在text()函数销毁前执行“析构函数” Person p1; // 4.给p1中的m_Age赋值为10 p1.m_Age = 10; // 5.屏幕显示：Person age = 10 cout &lt;&lt; \"Person age = \" &lt;&lt; p1.m_Age &lt;&lt; endl; // 6.p1做为参数传入doWork函数，注意这里是值传递（那为什么呢？） doWork(p1); // 12.并不能改变实参，所以我们可以知道，拷贝构造函数 以值传递的方式 给函数参数 传值 cout &lt;&lt; \"Person age = \" &lt;&lt; p1.m_Age &lt;&lt; endl;&#125;// 1.首先看这里，这里是主函数，程序的开始int main()&#123; // 2.调用test函数 test(); system(\"pause\"); return 0;&#125; 如果文章有错误，欢迎指正：2892870137@qq.com","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://jamesliu.com/tags/C/"},{"name":"编程","slug":"编程","permalink":"http://jamesliu.com/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"Markdown简单入门","slug":"Markdown","date":"2020-04-13T03:29:52.000Z","updated":"2020-06-09T03:20:53.408Z","comments":true,"path":"2020/04/13/Markdown/","link":"","permalink":"http://jamesliu.com/2020/04/13/Markdown/","excerpt":"以下是Markdown的最基本使用方法，忘记便回来看看，也就入了门","text":"以下是Markdown的最基本使用方法，忘记便回来看看，也就入了门 一级标题# 一级标题 二级标题## 二级标题 三级标题### 三级标题 分割线：--- 列表1 列表2 子列表1 子列表2 孙列表1 孙列表2 123456- 列表1- 列表2 - 子列表1 - 子列表2 - 孙列表1 - 孙列表2 分割线 ：--- 超链接 ：[超链接](https://github.com/H-James) 图片 ： 1![图片](https:&#x2F;&#x2F;h-james.github.io&#x2F;2020&#x2F;04&#x2F;13&#x2F;Markdown&#x2F;003_Markdown简单入门-rickAndmorty.png) 分割线 ：--- 斜字体 ：*斜字体* 粗字体 ：**粗字体** 一行代码 ： &lt;html&gt;代码&lt;/html&gt; 一段代码 ： 123456&lt;html&gt; &lt;head&gt; &lt;title&gt;代码&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 引用内容&gt; 引用内容","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://jamesliu.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"markdown","slug":"markdown","permalink":"http://jamesliu.com/tags/markdown/"}]}],"categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://jamesliu.com/tags/C/"},{"name":"编程","slug":"编程","permalink":"http://jamesliu.com/tags/%E7%BC%96%E7%A8%8B/"},{"name":"前端","slug":"前端","permalink":"http://jamesliu.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"markdown","slug":"markdown","permalink":"http://jamesliu.com/tags/markdown/"}]}